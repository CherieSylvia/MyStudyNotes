# 1. junit单元测试

1.  测试分类：
   - 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。
   - 白盒测试：需要写代码。关注程序具体的执行流程

2.  Junit使用：白盒测试

   步骤：

   - 定义一个测试类（测试用例）

     ​	建议：

     ​	测试类名：被测试的类名Test        例如：CalculatorTest

     ​	包名：xxx.xxx.xx.test                     例如：cn.itcast.test

   - 定义测试方法：可以独立运行
   - 给方法加@Test
   - 导入Junit依赖环境

   判定结果：

   ​	红色：失败

   ​	绿色：成功

   ​	一般我们使用断言操作来处理结果

   ​		`Assert.assertEquals(期望的结果，运算的结果);`

```java 
public class Calculator {
    public int sum(int a,int b) {
        return a + b;
    }
}
```

```java 
public class CalculatorTest {
    @Test
    public void testAdd() {
//        System.out.println("我被执行了！");
        Calculator c = new Calculator();
        int result = c.sum(1,2);
        Assert.assertEquals(3,result);
    }
}
```

​		补充：

​			@Before：修饰的方法会在测试方法之前自动执行

​			@After：修饰的方法会在测试方法之后自动被执行

# 2. 反射：框架设计的灵魂

1.  框架：半成品软件。可以在框架的基础上进行软件开发，简化编码

* 反射：将类的各个组成部分封装为其他对象，这就是反射机制
	* 好处：
		1. 可以在程序运行过程中，操作这些对象。
		2. 可以解耦，提高程序的可扩展性。

2. Java在计算机中的三个阶段

   源代码阶段 -> 类对象阶段 -> 运行时阶段

![java在计算机中的三个阶段](D:\les sylvia de documents\StudyNotes\java\JavaWeb\img\java在计算机中的三个阶段.png)

## 2.1 获取class对象的方式

1. Class.forName("全类名")：将字节码文件加载进内存，返回Class对象
   - 多用于配置文件，将类名定义在配置文件中。读取文件，加载类
2. 类名.class：通过类名的属性class获取
   -  多用于参数的传递
3. 对象.getClass()：getClass()方法在Object类中定义着。
   - 多用于对象的获取字节码的方式

* 结论：
	**同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。**

```Java
public class ReflectDemo01 {
    public static void main(String[] args) throws ClassNotFoundException {
        //1.Class.forName("全类名")
        Class<?> cls1 = Class.forName("Day01.Reflect.Person");
        System.out.println(cls1);  //class Day01.Reflect.Person
        //2.类名.class
        Class<Person> cls2 = Person.class;
        System.out.println(cls2);  //class Day01.Reflect.Person
        //3.对象.getClass
        Person person = new Person();
        Class<? extends Person> cls3 = person.getClass();
        System.out.println(cls3);  //class Day01.Reflect.Person

        System.out.println(cls1 == cls2);  //true
        System.out.println(cls1 == cls3);  //true
    }
}
```

## 2.2 获取class对象功能：

1. 获取成员变量

   * `Field[] getFields() ：`获取**所有public修饰的成员变量**
   * `Field getField(String name)`   获取**指定名称**的 public修饰的成员变量
   * `Field[] getDeclaredFields()`  获取**所有的成员变量，不考虑修饰符**
   * `Field getDeclaredField(String name)`

   ```
   Field：成员变量
   	操作：
   		1. 设置值
   			 void set(Object obj, Object value)  
   		2. 获取值
   			 get(Object obj) 
   
   		3. 忽略访问权限修饰符的安全检查
   			 setAccessible(true):暴力反射
   ```

   ```java
   public class ReflectDemo02 {
       public static void main(String[] args) throws Exception {
           //获取Person的class对象
           Class<Person> personClass = Person.class;
   
           //getFields：获取所有public修饰的成员变量
           Field[] fields = personClass.getFields();
           for (Field field : fields) {
               System.out.println(field);  //public java.lang.String Day01.Reflect.Person.a
           }
   
           //getField：获取public修饰的成员变量a   get(Object obj) :获取值
           Field a = personClass.getField("a");
           Person p = new Person();
           Object v1 = a.get(p);
           System.out.println(v1);  //null
           a.set(p,"张三");
           System.out.println(a.get(p));  //张三
       }
   }
   ```

1. 获取构造方法
   * `Constructor<?>[] getConstructors()`  
   * `Constructor<T> getConstructor(类<?>... parameterTypes)`  
   * `Constructor<T> getDeclaredConstructor(类<?>... parameterTypes)`  
   * `Constructor<?>[] getDeclaredConstructors()`  
2. 获取成员方法
   * `Method[] getMethods()`  
   * `Method getMethod(String name, 类<?>... parameterTypes)`  
   * `Method[] getDeclaredMethods()`  
   * `Method getDeclaredMethod(String name, 类<?>... parameterTypes)`
3. 获取全类名
   - `String getName()`  