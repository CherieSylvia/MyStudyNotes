# 1. 冗余的Lambda场景

来看一个简单的函数式接口以应用Lambda表达式： 

```Java
@FunctionalInterface 
public interface Printable { 
    void print(String str); 
}
```

在 Printable 接口当中唯一的抽象方法 print 接收一个字符串参数，目的就是为了打印显示它。那么通过Lambda来使用它的代码很简单： 

```Java
public class Normal {
    public static void printString(Printable p) {
        p.print("hello");
    }

    public static void main(String[] args) {
        printString((s) -> System.out.println(s));
    }
}
```

# 2. 问题分析

这段代码的问题在于，对字符串进行控制台打印输出的操作方案，明明已经有了现成的实现，那就是 `System.out` 对象中的 `println(String)` 方法。既然Lambda希望做的事情就是调用 `println(String)` 方法，那何必自己手动调 用呢？ 

# 3. 改进代码

```Java
public class Normal {
    public static void printString(Printable p) {
        p.print("hello");
    }

    public static void main(String[] args) {
        printString(System.out::println);
    }
}
```



# 1. 方法引用符

双冒号 :: 为引用运算符，而它所在的表达式被称为**方法引用**。如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。 