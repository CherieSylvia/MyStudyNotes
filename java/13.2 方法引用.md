# 1. 冗余的Lambda场景

来看一个简单的函数式接口以应用Lambda表达式： 

```Java
@FunctionalInterface 
public interface Printable { 
    void print(String str); 
}
```

在 Printable 接口当中唯一的抽象方法 print 接收一个字符串参数，目的就是为了打印显示它。那么通过Lambda来使用它的代码很简单： 

```Java
public class Normal {
    public static void printString(Printable p) {
        p.print("hello");
    }

    public static void main(String[] args) {
        printString((s) -> System.out.println(s));
    }
}
```

# 2. 问题分析

这段代码的问题在于，对字符串进行控制台打印输出的操作方案，明明已经有了现成的实现，那就是 `System.out` 对象中的 `println(String)` 方法。既然Lambda希望做的事情就是调用 `println(String)` 方法，那何必自己手动调 用呢？ 

# 3. 改进代码

```Java
public class Normal {
    public static void printString(Printable p) {
        p.print("hello");
    }

    public static void main(String[] args) {
        printString(System.out::println);
    }
}
```

# 4. 方法引用符

双冒号 :: 为引用运算符，而它所在的表达式被称为**方法引用**。如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。 

### 语义分析

上例中， System.out 对象中有一个重载的 println(String) 方法恰好就是我们所需要的。那么对于 printString 方法的函数式接口参数，对比下面两种写法，完全等效：

- Lambda表达式写法： `s -> System.out.println(s);` 

- 方法引用写法： `System.out::println` 

第一种语义是指：拿到参数之后经Lambda之手，继而传递给 `System.out.println` 方法去处理。 

第二种等效写法的语义是指：直接让 `System.out` 中的 `println` 方法来取代Lambda。两种写法的执行效果完全一 样，而第二种方法引用的写法复用了已有方案，更加简洁。 

> 注:Lambda 中 传递的参数一定是方法引用中 的那个方法可以接收的类型,否则会抛出异常 